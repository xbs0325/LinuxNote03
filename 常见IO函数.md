# 常见IO函数

### 目录

 ### 	Ⅰ、[open函数](#1.open函数)

### 	Ⅱ、[close函数](#2.close函数)

### 	Ⅲ、[write函数](#3.write函数)

### Ⅳ、[read函数](#4.read函数)

### Ⅴ、[lseek函数](#5.lseek函数)



#### 其他知识点:

#### 	①:[open与fopen的区别](#open与fopen的区别)

#### 	②:[数字权限](#数字含义:)

#### 	③:[阻塞和非阻塞概念](#阻塞和非阻塞概念)

## 1.open函数

### 	open与fopen的区别

| open                                               | fopen               |
| -------------------------------------------------- | ------------------- |
| 低级IO                                             | 高级IO              |
| 非缓冲文件系统                                     | 缓冲文件系统        |
| 返回文件描述符 属于用户态 需进行用户态和内核态切换 | 返回文件指针        |
| 一般打开设备文件                                   | 打开普通文件        |
| 随机访问快                                         | 顺序访问快          |
| 是系统函数，不可移植                               | 是标准C函数，可移植 |



```
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

int open(const char* pathname, int flags);
int open(const char* pathname, int flages, mode_t mode);
功能:
	打开文件，如果文件不存在则创建
参数:
	pathname: 文件的路径及文件名
	flags: 打开文件的行为标，必须选O_RDONLY, O_WRONLY, O_RDWR
	mode: 这个参数，只有文件不存在时有效，指新建文件时指定文件的权限
返回值:
	成功: 返回打开的文件描述符
	失败: -1
```

#### flags详细说明

必选项:

| 取值     | 含义                   |
| -------- | ---------------------- |
| O_RDONLY | 以只读的方式打开       |
| O_WRONLY | 以只写的方式打开       |
| O_RDWR   | 以可读，可写的方式打开 |

可选项，`必选项 | 可选项`

| 取值       | 含义                                                       |
| ---------- | ---------------------------------------------------------- |
| O_CREAT    | 文件不存在则创建文件，使用此选项时需使用mode说明文件的权限 |
| O_EXCL     | 如果同时指定了O_CREAT,且文件已经存在，则出错               |
| O_TRUNC    | 如果文件存在，则清空文件内容                               |
| O_APPEND   | 写文件时，数据添加到文件末尾                               |
| O_NONBLOCK | 对于设备文件，以O_NONBLOCK方式打开可以做非阻塞I/O          |

```
fd = open("txt",O_RDONLY | O_CREAT , 0644)
//以只写打开文件 文件不存在时创建 存在时直接打开 权限0644 

fd = open("txt", O_RDONLY | O_CREAT | O_EXCL, 0644)
//以只读打开文件 文件不存在时创建 文件存在时报错（文件已存在）权限0644

fd = open("txt", O_WRONLY | O_CREAT | O_TRUNK, 0644)
//以只写打开文件 文件不存在时创建 文件存在时清空内容 权限0644

fd = open("txt" ,O_WRONLY | O_APPEND, 0644)
//以只写打开文件 文件存在时追加写入 如果文件不存在则会报错 权限0644
```



注: 0644 	0处为特殊权限位 644分别对应ugo -> user group others

[跳转目录](#目录)

#### 数字含义:

| 数字 | 二进制      | 代表含义 |
| ---- | ----------- | -------- |
| 0    | 0           | ---      |
| 1    | 2^0         | --x      |
| 2    | 2^1         | -w-      |
| 3    | 2^1+2^0     | -wx      |
| 4    | 2^2         | r--      |
| 5    | 2^2+2^0     | r-x      |
| 6    | 2^2+2^1     | rw-      |
| 7    | 2^2+2^1+2^0 | rwx      |

[跳转目录](#目录)

注：只有需要 文件描述符 参数时才需要打开文件(如使用stat等函数时不需要打开)

## 2.close函数

```
#include <unistd.h>

int close(int fd);
功能:
	关闭已打开的文件
参数:
	fd: 文件描述符,open()的返回值
返回值:
	成功: 0
	失败: -1，并设置errno
```

​	需要说明的，当一个进程终止时，内核对该进程所有尚未关闭的文件描述符用close关闭，所以即使用户程序不调用close，在终止时函数也会自动关闭他打开的所有文件。

​	但对于一个长年累月运行的程序（比如网络服务器），打开的文件描述符一定要记得关闭，否则随着打开的文件越来越多，会占用大量文件描述符和系统资源

[跳转目录](#目录)

## 3.write函数

```
#include <unistd.h>
ssize_t write(int fd, const void *buf,size_t count);
功能:
	把指定的目录数据写入文件(fd)
参数:
	fd: 文件描述符
	buf: 数据首地址
	count: 写入数据的长度(字节)
返回值:
	成功:实际写入数据的字节个数
	失败: -1
```

[跳转目录](#目录)

## 4.read函数

```
#include <unistd.h>
ssize_t read(int fd, void* bud, size_t count)
功能:
	把指定数目的数据读到内存(缓冲区)
参数:
	fd: 文件描述符
	buf: 内存首地址
	count: 读取的字节个数
返回值:
	成功:实际读取的字节个数
	失败: -1
```

[跳转目录](#目录)



##### 阻塞和非阻塞概念

​	读常规文件是不会阻塞的，不管多少字节，read一定会在有限的时间内返回

从终端设备或网络读则不一定，如果从终端输入的数据没有换行符，调用read读终端设备就会阻塞，如果网络上没有接收到数据包，调用read从网络中读就会阻塞，至于会堵塞多长时间也是不确定的，如果一直没有数据到达就一直阻塞在那里。

​	同样，写常规文件是不会阻塞的，而向终端设备或者网络写则不一定。

**【注意】 阻塞与非阻塞是对于文件而言的，而不是指read，write等属性的**



[跳转目录](#目录)

## 5.lseek函数



```
#include <sys/types.h>
#include <unistd.h>

off_t lseek(int fd, off_t offset, int whence)
功能:
	改变文件的偏移量
参数:
	fd:文件描述符
	offset:根据whence来移动的位移数(偏移量)，可以是正数，也可以是负数，如果正数，则相对于whence往右移动，如果是负数，则相对whence往左移动。如果向前移动的字节超过了文件开头则出错返回，如果向右移动的字节数超过了文件末尾，再次写入时将增大文件尺寸。
	
	whence：其取值如下
		SEEK_SET：从文件开头移动offset个字节
		SEEK_CUR：从当前位置移动offset个字节
		SEEK_END：从文件末尾移动offset个字节
返回值：
	若lseek成功执行，则返回新的偏移量
	如果失败，范围-1
```



​	所有打开的文件都有一个当前文件偏移量(current file offset)，以下简称为cfo。cfo通常是一个非负整数，用于表明文件开始处到文件当前位置的字节数。

​	读写操作通常开始于cfo，并且使cfo增大，增量为读写的字节数。文件被打开时，cfo会被初始化为0，除非使用了O_APPEND

注:若write之后直接read 读不到任何东西因为文件指针指向了末尾